--CONECTION E RECORD

DECLARE 
--
TYPE REC_ALUNO IS RECORD --CRIA UM RECORD COM 2 COLUNAS
(COD_ALUNO NUMBER NOT NULL := 0,
NOME *TABELA*.NOME%TYPE);
REGISTRO REC_ALNO; --REGISTRO RECEBE OS MESMOS ITENS DO RECORD
BEGIN
  REGISTRO.COD_ALINO := 50;
  REGISTRO.NOME := 'ADDAM';
  
  DBMS_OUTPUT.PUT_LINE('CODIGO: '||REGISTRO.COD_ALUNO); --CHAMA O REGISTRO COM OS VALORES
  DBMS_OUTPUT.PUT_LINE('NOME: '||REGISTRO.NOME);
END;

DECLARE 
--
REG *TABELA*%ROWTYPE; --RECORD DA TABELA COMPLETA
BEGIN
  SELECT CODIGO, NOME, CIDADE
  INTO REG.COD, REG.NOME, REG.CIDADE
  FROM *TABELA*
  WHERE CODIGO = 1
  VCEP := '000000000'
  REG.CEP := VCEP;
  DBMS_OUTPUT.PUT_LINE();
END;

DECLARE
TYPE NOME_MATRIZ IS TABLE OF *TABELA*.NOME%ROWTYPE
INDEX BY BINARY_INTEGER; --MATRIZ
REGISTRO NOME_MATRIZ;
BEGIN
REGISTRO(1) := 'CACAU'; --DEFINE QUE NO PRIMEIRO INDICE DA MATRIZ RECEBE O VALOR INFORMADO
REGISTRO(2)...
DBMS_OUTPUT.PUT_LINE();
END;

DECLARE
TYPE NOME_TYPE IS TABLE OF *TABELA*.NOME%ROWTYPE;
NOME_TABELA NOME_TYPE := NOME_TYPE(); --CRIANDO INSTANCIA
BEGIN
NOME_TABELA.EXTEND; --ALOCA UMA NOVA LINHA
NOME_TABELA(1) := 'CACAU';
NOME_TABELA.EXTEND; --ALOCA UMA NOVA LINHA
NOME_TABELA(2) := ''
....
DBMS_OUTPUT.PUT_LINE();
END;

DECLARE
TYPE TIPO IS TABLE OF VARCHAR(40) INDEX BY VARCHAR(2); --A CHAVE PRIMARIA VAI SER UM VARCHAR DE 2 POSIÇÕES
UF_CAPITAL TIPO;
BEGIN
UF_CAPITAL('RS') := 'PORTO ALEGRE';
...
DBMS_OUTPUT.PUT_LINE();
END;

--VARRAY
DECLARE
TYPE NOME_VARRAY IS VARRAY(5) OF *TABELA*.NOME%TYPE; --VETOR COM TAMANHO DEFINIDO, NESTE CASO COM ATÉ 5 INDICES(LINHAS)
NOME_VETOR NOME_VARRAY := NOME_VARRAY();
BEGIN
NOME_VETOR.EXTEND;
NOME_VETOR(1) = 'CACAU';
DBMS_OUTPUT.PUT_LINE();
END;

----------------------------------------------------------------------------------------
--FUNCTION PIPELINED COM MATRIZ
--CRIA ARRAY 
CREATE OR REPLACE TYPE REG_ALUNO AS OBJECT
(CODIGO INTEGER,
NOME VARCHAR(20),
CIDADE VARCHAR(15));
--TRANSFORMA O ARRAY EM MATRIZ
CREATE OR REPLACE TYPE TABLE_REG_ALUNO AS TABLE OF REG_ALUNO;
--FUNCTION QUE RETORNAM OS REGISTROS
CREATE OR REPLACE FUNCTION GET_ALUNO(P_COD NUMBER) --RETORNA APENAS UM REGISTRO
RETURN TABLE_REG_ALUNO PIPELINED
IS
OUTLISTA REG_ALUNO; --CRIA UMA VARIAVEL DO TIPO DO MATRIZ 
CURSOR CSQL IS
SELECT ALU.COD_ALUNO, ALU.NOME, ALU.CIDADE
FROM *TABELA* ALU
WHERE ALI.COD_ALU = P_COD;
REG CSQL%ROWTYPE; --VARIAVEL DO MESMO TYPE DO CURSOR
BEGIN
OPEN CSQL;
FETCH CSQL INTO REG; --PEGA O RESULTADO DO CURSOR E JOGA PRA REG
OUTLISTA := REG_ALUNO(REG.COD_ALUNO, REG.NOME, REG.CIDADE); --PREENCHE OS CAMPOS DO OUTLISTA
PIPE ROW(OUTLISTA); --ESCREVE A LINHA
CLOSE CSQL; --FECHA CURSOR
RETURN; --RETORNA OS DADOS PRA VARIAVEL
END;
--PARA FAZER A CHAMADA
SELECT * FROM TABLE(GET_ALUNO(1)); --TABLE NESTE CASO, FAZ UMA CONVERSÃO DO SELECT

SELECT * ALU.*, CON.TOTAL
FROM TABLE(GET_ALUNO(1)) ALU, *TABELA* CON
WHERE CON.COD_ALUNO = ALU.CODIGO
--------------------------------------------------------------------------------------------

--MESMO OBJETIVO DA FUNCTION ACIMA, PORÉM RETORNA TODOS OS DADOS E SEM A CLAUSULA WHERE

CREATE OR REPLACE FUNCTION GET_ALUNOS RETURN TABLE_REG_ALUNO PIPELINED --UTILIZANDO OS MESMOS PARAMETROS DA FUNCTION ACIMA
IS
OUTLISTA REG_ALUNO;
CURSOR CSQL IS
SELECT COD_ALUNO, NOME, CIDADE FROM *TABELA*;
REG CSQL%ROWTYPE;
BEGIN 
FOR REG IN CSQL
LOOP
OUTLISTA := REG_ALUNO(REG.COD_ALUNO, REG.NOME, REG.CIDADE); --PREENCHE OS CAMPOS DO OUTLISTA
PIPE ROW(OUTLISTA); --ESCREVE A LINHA
END LOOP;
RETURN;
AND;

--USANDO
SELECT * FROM TABLE(GET_ALUNOS)--NESTE CASO RETORNA TODOS OS ALUNOS
--------------------------------------------------------------------------------------------