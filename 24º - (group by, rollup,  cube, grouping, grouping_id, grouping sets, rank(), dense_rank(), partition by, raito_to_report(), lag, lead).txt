SELECT COD, Trunc(DATA),
Sum(DESCONTO) DESCONTO,
Sum(TOTAL) TOTAL
FROM *TABELA*
GROUP BY ROLLUP(COD, Trunc(DATA)); --ROLLUP GERA UM SUBTOTAL DAS LINHAS --GROUP BY PELO COD E DATA
--EX: GROUP BY ROLLUP
--LINHA 1: COD: 5, DESC: 5, VL: 11, DATA: 25/08
--LINHA 2: COD: 5, DESC: 4, VL: 06, DATA: 18/07
--SUB-TOT: COD: 5, DESC: 9, VL: 17, DATA: NULL
--FINAL-L: NULL, DESC: 9, VL: 17, DATA: NULL --ESSA LINHA FINAL GERA UM SUBTOTAL DE TODOS OS IDS DA TABELA
--------------------------------------------------------------------

SELECT COD,
CASE
WHEN Trunc(DATA) IS NULL AND COD IS NOT NULL THEN 'SUB-TOTAL'
WHEN COD IS NULL THEN 'TOTAL'
ELSE To_Char(Trunc(DATA))
END DESCRICAO,
Round(Avg(DESCONTO), 2) DESCONTO, --FAZ UMA MÉDIA DO DESCONTO NO SUBTOTAL
Sum(TOTAL) TOTAL
FROM *TABELA*
GROUP BY ROLLUP(COD, Trunc(DATA));
--A MESMA FUNÇÃO QUE A ANTERIOR, A DIFERENÇA É QUE SUBSTITUI A ULTIMA LINHA "NULL" POR "TOTAL"
--E OS SUBTOTAIS "DATA" QUE É NULL, VEM PREENCHIDO COM "SOB-TOTAL"
--FAZ UMA MÉDIA DOS DESCONTOS NO SUBTOTAL
------------------------------------------------------------------------

SELECT COD, Trunc(DATA), Sum(TOTAL) FROM *TABELA*
GROUP BY CUBE(COD, Trunc(DATA));
--CUBE É MUITO SEMELHANTE AO ROLLUP, PORÉM RETORNA ALGUMAS INFORMAÇÕES A MAIS
--POR EXEMPLO, NESTE CASO, RETORNA O TOTAL POR "COD" E "DATA" SEPARADAMENTE
-------------------------------------------------------------------------

SELECT Grouping(COD), --GROUPING IDENTIFICA UM TOTAL GERAL
CASE
WHEN Grouping(COD) = 0 THEN To_Char(COD)
ELSE 'TOTAL-GERAL: '
END *NOME*,
Sum(TOTAL) AS TOTAL
FROM *TABELA*
GROUP BY ROLLUP(COD);
--AGRUPA O VALOR POR COD, A LINHA FINAL 'NULL' É RENOMEADA PARA 'TOTAL-GERAL' E SOMA TODOS OS VALORES DOS CODS 
--------------------------------------------------------------------------

SELECT Trunc(DATA),
GROUPING_ID(Trunc(DATA)) GDT, --GROUPING IDENTIFICA UM SUB-TOTAL
COD,
GROUPING_ID(COD) GCL,
Sum(TOTAL)
FROM *TABELA*
GROUP BY ROLLUP(Trunc(DATA), COD);
--DATA GDL IDENTIFICOU COMO UM TOTAL(1)
--COD GCL IDENTIFICOU COMO UM TOTAL(1)
--NA COLUNA GCL O QUE FOR REGISTRO COMUM IRÁ RETORNAR (0), O QUE FOR SUB-GRUPO RETORNA COMO (1)
----------------------------------------------------------------------------

SELECT Trunc(DATA), COD,
CASE
WHEN GROUPING_ID(COD) = 1 AND
GROUPING_ID (TRUNC(DATA)) =0 THEN 'TOTAL DO DIA: '
WHEN GROUPING_ID(COD) = 1 AND
GROUPING_ID (TRUNC(DATA)) =1 THEN 'TOTAL GERAL: '
END AS DESCRICAO,
Sum TOTAL
FROM *TABELA*
GROUP BY ROLLUP(Trunc(DATA), COD);
--A MESMA FUNÇÃO QUE A ANTERIOR, A DIFERENÇA É QUE SUBSTITUI OS RETORNOS (0, 1) DE ACORDO COM A CONDIÇÃO ESPECIFICADA
-----------------------------------------------------------------------------

SELECT COD, Trunc(DATA), Sum(TOTAL)
FROM *TABELA*
GROUP BY Grouping SETS(COD, Trunc(DATA));
--RETORNA SOMENTE OS SUBTOTAIS POR CODIGO E POR DATA
------------------------------------------------------

--DA UM RANKEAAMENTE CONFORME O (NESTE CASO) O VALOR TOTAL
-- 1 - 1 - 3 - 4 - 4 - 6
SELECT Trunc(DATA), COD, Sum(TOTAL),
Rank() OVER (ORDER BY Sum(TOTAL) DESC) AS POSICAO --RETORNA O RANKING ORDENADO PELA SOMA DO TOTAL
FROM *TABELA*
GROUP BY (Trunc(DATA), COD)
------------------------------------------------------

--PARTITION AGRUPA (NESTE CASO) POR DATA, ENTÃO RETORNA UM RANKING POR DIA DOS CODIGOS
--TRAZ O RANKING POR DIA
SELECT Trunc(DATA), COD, Sum(TOTAL),
Rank() OVER (PARTITION BY Trunc(DATA) ORDER BY Sum(TOTAL) DESC) AS POSICAO
FROM *TABELA*
GROUP BY (Trunc(DATA), COD)
ORDER BY Trunc(DATA)
------------------------------------------------------

SELECT COD, TOTAL,
Rank() OVER(ORDER BY TOTAL DESC) "RANK", -- 1 - 2 - 2 - 4 - 5 - 5 - 7
Dense_Rank() OVER(ORDER BY TOTAL DESC) "DENSE_RANK" -- 1 - 2 - 2 - 3 - 4 - 4 - 5
FROM *TABELA*
GROUP BY COD, TOTAL;
--A DIFERENÇA DO RANK PRO DENSE É QUE O DENSE NÃO PULA CASAS NO CASO DE EMPATE
------------------------------------------------------

--RATIO TO REPORT() MOSTRA UM PERCENTUAL DE CADA REGISTRO SOBRE O PERCENTUAL TOTAL
SELECT COD, Sum(TOTAL) 'TOTAL DO CLIENTE',
Round(Ratio_To_Report(Sum(TOTAL)) OVER()*100, 2)" % DO TOTAL" -- ',2' FAZ PARTE DO ROUND(ARREDONDA CASAS DECIMAIS)
FROM *TABELA*
GROUP BY COD;
-------------------------------------------------------
--EXIBE UM PERCENTUAL DE TODOS OS REGISTROS POR DIA SOBRE UM PERCENTUAL TOTAL
SELECT COD,
Trunc(DATA),
Sum(TOTAL) "TOTAL DO DIA",
Round(Ratio_To_Report(Sum(TOTAL)) OVER (PARTITION BY Trunc(DATA)) *100, 2) "% DO DIA"
FROM *TABELA*
GROUP BY COD, Trunc(DATA)
ORDER BY 2 ASC, COD; 

--------------------------------------------------------

SELECT Trunc(DATA), Sum(TOTAL) "TOTAL_DO_DIA",
Lag (Sum(TOTAL), 1) OVER (ORDER BY Trunc(DATA)) ANTERIOR
Lead(Sum(TOTAL), 1) OVER (ORDER BY Trunc(DATA)) AS POSTERIOR
FROM *TABELA*
GROUP BY Trunc(DATA)
ORDER BY Trunc(DATA);
--NA LINHA, SERÁ EXIBIDO A DATA, O VALOR TOTAL (ATUAL), O VALOR TOTAL(ANTERIOR) E O VALOR TOTAL(POSTERIOR)
 